#!/usr/bin/env node

var fs        = require('fs'),
    path      = require('path'),
    url       = require('url'),
    http      = require('http'),
    https     = require('https'),
    async     = require('async'),
    commander = require('commander'),
    exec      = require('child_process').exec,
    mkdirp    = require('mkdirp'),
    stync     = require('stync'),
    deftInfo  = parseFile('../package.json');

function readFile(filePath, basePath) {
  basePath = basePath || __dirname;
  return fs.readFileSync(path.join(basePath, filePath), 'utf-8');
}

function parseFile(filePath, basePath) {
  return JSON.parse(readFile(filePath, basePath));
}

commander
  .version(deftInfo.version)
  .option('-c, --config-file <path>', 'specify a config file (defaults to deft.json)')
  .option('-f, --force', 'overwrite files that are already present')
  .parse(process.argv);

var configFile   = commander.configFile || 'deft.json',
    config       = parseFile(configFile, process.cwd()),
    destination  = getDestination(config.destination || 'deft'),
    dependencies = config.dependencies || [];

function getDestination(configDestination) {
  if (typeof configDestination === 'string') {
    return { '*': configDestination };
  }

  return configDestination;
}

function getDestinationPath(fileName) {
  var extension = path.extname(fileName),
      folder    = destination[extension] || destination[extension.substring(1)] || destination['*'];

  if (!folder) {
    throw 'Unsure where to save file "' + fileName + '"!';
  }

  return path.join(process.cwd(), folder, fileName);
}

function shouldOverwrite(filePath) {
  if (!(fs.existsSync || path.existsSync)(filePath)) {
    return true;
  }

  return commander.force;
}

function writeFile(filePath, response, callback) {
  // Ensure destination directory exists
  mkdirp.sync(path.dirname(filePath));

  var stream = fs.createWriteStream(filePath);
  response.pipe(stream);
  stream.on('finish', callback);
}

function copyFile(source, destination) {
  fs.createReadStream(source).pipe(fs.createWriteStream(destination));
}

function randomNumber() {
  return Math.floor(Math.random() * 1000000);
}

function getTempFileName(extension) {
  var fileName;

  do {
    fileName = 'temp' + randomNumber() + '.' + extension;
  } while (fs.existsSync(fileName));

  return fileName;
}

function getTempDirName() {
  var dirName;

  do {
    dirName = 'tmp' + randomNumber();
  } while (fs.existsSync(dirName));

  return dirName;
}

function waitForDirToExist(path, callback) {
  if (fs.existsSync(path)) {
    callback();
    return;
  }

  setTimeout(function() {
    waitForDirToExist(path, callback);
  }, 250);
}

function getFiles(files) {
  if (typeof files === 'string') {
    return filesFromString(files);
  }

  if (files instanceof Array) {
    return filesFromArray(files);
  }

  return files;
}

function filesFromString(string) {
  var object = {};
  object[string] = path.basename(string);
  return object;
}

function filesFromArray(array) {
  var object = {};
  for (var i = 0; i < array.length; ++i) {
    object[array[i]] = path.basename(array[i]);
  }
  return object;
}

function getUrl(file, dependency) {
  if ((/^https?:/).test(dependency[0])) {
    return url.resolve(dependency[0], file);
  }

  var name = dependency[0],
      tag  = dependency.length > 2 ? dependency[1] : 'master';

  return 'https://raw.github.com/' + name + '/' + tag + '/' + file;
}

function getHttpModule(url) {
  return (/^https:/).test(url) ? https : http;
}

function describesArchive(files) {
  var keys = Object.keys(files);
  return keys.length === 1 && keys[0] === 'archive' && typeof files.archive === 'object';
}

function extractCommand(fileType) {
  switch (fileType) {
    case 'zip': return 'unzip';
    default: throw 'Unrecognized file type: ' + fileType;
  }
}

function downloadArchive(archive, dependency) {
  var url        = dependency[0],
      type       = archive.type || 'zip',
      files      = getFiles(archive.files),
      httpModule = getHttpModule(url);

  var message = stync.begin('Downloading ' + url + '...');
  httpModule.get(url, function(response) {
    var fileName   = getTempFileName(type),
        tempDir    = getTempDirName(),
        fileStream = fs.createWriteStream(fileName);

    message.write(' received response; saving to disk...');
    response.pipe(fileStream);

    response.on('end', function() {
      message.write(' extracting file...');

      var command = [
        extractCommand(type),
        fileName,
        Object.keys(files).join(' '),
        '-d ' + tempDir
      ].join(' ');

      exec(command, function(err) {
        if (err) {
          message.end(' error! ' + err);
          return;
        }

        message.end(' Done.');

        waitForDirToExist(tempDir, function() {
          for (file in files) {
            stync.write('Copying ' + file + '...');
            copyFile(path.join(tempDir, file), getDestinationPath(files[file]));
          }
        });
      });
    });
  });
}

function downloadDependency(dependency) {
  var files = getFiles(dependency[dependency.length - 1]);

  if (describesArchive(files)) {
    downloadArchive(files.archive, dependency);
    return;
  }

  var retrieveFile = function(file) {
    var fileUrl         = getUrl(file, dependency),
        httpModule      = getHttpModule(fileUrl),
        destinationPath = getDestinationPath(files[file]);

    if (shouldOverwrite(destinationPath)) {
      var message = stync.begin('Downloading ' + file + '...');
      httpModule.get(fileUrl, function(response) {
        message.write(' received response...');

        writeFile(destinationPath, response, function() {
          message.end(' Done.');
        });
      });

    } else {
      stync.write(file + ' - already present');
    }
  };

  async.each(Object.keys(files), retrieveFile, function(err) {
    if (err) {
      console.log('Encountered an error: ' + err);
    }
  });
}

async.each(dependencies, downloadDependency, function(err) {
  if (err) {
    console.log('Encountered an error: ' + err);
  }
});
